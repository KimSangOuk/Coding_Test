# 풀이시간 초과 시간제한 2초 메모리제한 128MB
# 1회차 오답 - 풀이방법에 접근 못함, 풀이시간 초과
# 데이터의 수가 n^2에다가 100,000이기 때문에 직접적으로 문제에 나와있는데로 모든 배열을 넣을 수 없음까지는 알았다. NlogN까지 가능하다고 생각을 했고 일단 시간복잡도 상으로는 이진탐색을 사용하고 N회를 안이나 밖으로 시행하는 방법이 있다고 생각했다. 특정 순서에서의 값을 구하는 문제였는데, 또 쓸데없이 규칙을 찾으려고 하였다. 규칙을 억지로 찾지 않고 앞에 있는 수나 뒤에 있는 수를 구해서 구하는 방법을 찾았어야 했다. 나름 그래도 나도 데이터의 수를 이용하려고 했던 것이, 2차원배열에서 수를 가지고 접근 하는 방법 중에 반으로 줄인다는 개념을 이용해서 구할 수 있지 않을까 생각을 했지만 구하지 못했다. 왜 접근하지 못했는가? 먼저 1차원 배열에서 찾으려고 하였다. 왜 1차원 배열에서 찾으려고 하였는가? 결국 주어진 값을 찾는 문제이기도 하고 2차원의 규칙이 1차원에 반영되는 형태라고 생각했기 때문에 1차원에서 계속해서 찾으려고 하였다. 즉, 특정 수에 열의 번호를 나누었을 때, 그 열에서의 그 수보다 작은 수의 갯수가 나온다고는 생각도 못했다. 2차원 배열에서 우리가 직접적으로 얻을 수 있다는게 2차원배열을 직접 사용하지 못할 때에는 거의 없다는 것을 알고 있었어야했다. 또한 직접 사용하지 못할 때, 우리가 가장 접근 하기 쉬운 것은 열과 행이라는 것을 인지해야 했다. 왜 이런것을 인지하지 못했는가? 2차원 배열을 직접적으로 접근하지 못하게 하는 문제는 처음 접하기도 하고, 직접적으로 접하지 못하였기 때문에 접근하는 측면에서 거의 배제 시키듯이 하였다. 
# 즉, 특정 조건을 주었으나 특정 조건을 건드리지 못하고 다른 곳에서 그 형태를 이용하여 풀어야할 때, 가장 접근하기 쉬운 조건을 우선적으로 탐색한다. 이 문제의 경우, 행과 열이 될 수 있다.
# 또한 규칙을 찾을 수 없다면 직접적으로 그 정답을 구하는데 필요한 방법을 직관적으로 바라볼 필요가 있다고 생각했다.
# 추가적으로 정렬되어 있다고 그 배열에서 무조건적으로 답을 찾을 수 있다는 것은 아닌 점도 배웠다. 

# 답안지
import sys

N = int(sys.stdin.readline().rstrip())
K = int(sys.stdin.readline().rstrip())

start = 1
end = N * N
result = 0

while start <= end:
    cnt = 0

    mid = (start + end) // 2

    for div in range(1, N + 1):
        cnt += min(mid // div, N)

    if cnt >= K:
        result = mid
        end = mid - 1
    else:
        start = mid + 1

print(result)