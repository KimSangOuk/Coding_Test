# 풀이시간 10분/30분 시간제한 1초 메모리제한 128MB
# 3회차 정답
# 현재 위치에서의 답을 dp에 기록한다고 하였을 때, 현재 위치에서의 dp[i]는 전의 가능한 2,3,5의 못생긴 수 중 가장 작은 수이다. 그렇기 때문에 현재의 해가, 전의 해로 이루어질 수 있기 때문에 다이나믹 프로그래밍 문제이다. 이 때, 곱해지는 수는 2,3,5이고 가장 작은 수를 기록하기 위해서는 각 2,3,5가 곱해질 작은 수의 인덱스를 따로 기록해 두면 된다. 현재의 수를 설정한 뒤 현재 설정된 수가 해당 수의 못생긴 수라면 그 수의 인덱스를 높여서 곱해졌던 가장 작은 수의 다음수를 가져오게 하면 2,3,5만 소인수로 가지는 수를 가져올 수 있다.

n=int(input())

dp=[0]*(n+1)
dp[1]=1
next_2=2
next_3=3
next_5=5
n2,n3,n5=1,1,1
for i in range(2,n+1):
    dp[i]=min(next_2,next_3,next_5)
    if dp[i]==next_2:
        n2+=1
        next_2=dp[n2]*2
    if dp[i]==next_3:
        n3+=1
        next_3=dp[n3]*3
    if dp[i]==next_5:
        n5+=1
        next_5=dp[n5]*5

print(dp[n])

# 풀이시간 10분/30분 시간제한 1초 메모리제한 128MB
# 2회차 정답 - 하지만 풀이방법이 달라서 다시 풀어보기로 함 
# 나의 경우는 간단하게 최대 수의 크기가 1000이기에 dp를 기록용으로 True False로 두고 앞으로 나아가면서 못생긴 수만을 체크한 다음 나중에 출력할 때 순서대로 출력하는 방법으로 하였다. 하지만 풀이가 더 dp를 전의 수를 저장하고 출력하는데 쓴다고 생각해서 다시 풀기로 하였다.
# 정답에서는 dp에 못생긴 수만을 담고 그 수가 다음수에 영향을 주는 식이다. 다음 수가 될 수들 중 가장 작은 수가 못생긴 수가 되고, 그 다음수는 2,3,5 배수 중 다음수로 뽑혔다면 다음수를 인덱스를 늘려서 업데이트 시켜놓는 식으로 푸는 것이다.
# 왜 이 방법을 생각힞 못했는가? 이번에는 저번과는 다르게 dp를 단지 기록용으로만 생각해서 TRUE와 FAlse를 넣어도 된다고 생각했기 때문이다. 저번까지의 값을 dp가 반영하게 했어야했는데 그 점을 놓쳤다.
# 즉, 단순히 dp는 기록용이 아니라 그 전까지의 값을 담는 형태로 풀어내야 다이나믹 프로그래밍 바텀 업 방식이라고 볼 수 있는 것이다.

target=int(input())

dp=[False]*1001
dp[1]=True
for i in range(1,1001):
  index_2=i*2
  if index_2<=1000:
    dp[index_2]=True
  index_3=i*3
  if index_3<=1000:
    dp[index_3]=True
  index_5=i*5
  if index_5<=1000:
    dp[index_5]=True

count=0
for i in range(1,1001):
  if dp[i]==True:
    count+=1
  if count==target:
    print(i)
    break


# 풀이시간 초과/30분 시간제한 1초 메모리제한 128MB
# 1회차 오답 - 풀이에 접근하지 못함
# 다이나믹 프로그래밍의 경우, 어떤 특정 한가지의 수만을 영향으로 받아 점화식처럼 규칙을 찾아서 풀어내는 방식이라는 한정적인 개념에 갇혀있었다. 이 문제처럼 불규칙적으로 인덱스의 값이 하나의 경우로 한정되지 않을 수도 있다는 것을 알게 되었다.
# 문제를 풀면서 인덱스의 값이 여러개의 변수가 아니고서는 풀어질 수 없다는 것을 알고 하나로 압축하는 방법이 존재할 것이라 생각해서 머리를 굴려봤지만 불가능했다.

# 1회차 풀이 - 풀이에 접근하지 못함
# 인덱스의 값이 여러개일 수밖에 없다는 결론에 도달했으나, 다이나믹 프로그래밍의 경우, 여러개면 안되고 하나에서 규칙이 있을 거라 생각해서 문제에 접근했으나 결국 해결하지 못함.
# 단순 알고리즘 개념의 오해의 문제였다.

# 답안 예시
n=int(input())

ugly=[0]*n # 못생긴 수를 담기 위한 테이블(1차원 DP 테이블)
ugly[0]=1 # 첫 번째 못생긴 수는 1

# 2배, 3배, 5배를 위한 인덱스
i2=i3=i5=0
# 처음에 곱셈값을 초기화
next2, next3, next5=2,3,5

# 1부터 n까지의 못생긴 수를 찾기
for i in range(1,n):
  # 가능한 곱셈 결과 중에서 가장 작은 수를 선택
  ugly[i]=min(next2,next3,next5)
  # 인덱스에 따라서 곱셈 결과를 증가
  if ugly[i]==next2:
    i2+=1
    next2=ugly[i2]*2
  if ugly[i]==next3:
    i3+=1
    next3=ugly[i3]*3
  if ugly[i]==next5:
    i5+=1
    next5=ugly[i5]*5

# n번째 못생긴 수를 출력
print(ugly[n-1])