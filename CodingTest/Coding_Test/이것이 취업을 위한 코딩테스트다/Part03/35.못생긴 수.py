# 풀이시간 초과/30분 시간제한 1초 메모리제한 128MB
# 1회차 오답 - 풀이에 접근하지 못함
# 다이나믹 프로그래밍의 경우, 어떤 특정 한가지의 수만을 영향으로 받아 점화식처럼 규칙을 찾아서 풀어내는 방식이라는 한정적인 개념에 갇혀있었다. 이 문제처럼 불규칙적으로 인덱스의 값이 하나의 경우로 한정되지 않을 수도 있다는 것을 알게 되었다.
# 문제를 풀면서 인덱스의 값이 여러개의 변수가 아니고서는 풀어질 수 없다는 것을 알고 하나로 압축하는 방법이 존재할 것이라 생각해서 머리를 굴려봤지만 불가능했다.

# 2회차 풀이





# 1회차 풀이 - 풀이에 접근하지 못함
# 인덱스의 값이 여러개일 수밖에 없다는 결론에 도달했으나, 다이나믹 프로그래밍의 경우, 여러개면 안되고 하나에서 규칙이 있을 거라 생각해서 문제에 접근했으나 결국 해결하지 못함.
# 단순 알고리즘 개념의 오해의 문제였다.

# 답안 예시
n=int(input())

ugly=[0]*n # 못생긴 수를 담기 위한 테이블(1차원 DP 테이블)
ugly[0]=1 # 첫 번째 못생긴 수는 1

# 2배, 3배, 5배를 위한 인덱스
i2=i3=i5=0
# 처음에 곱셈값을 초기화
next2, next3, next5=2,3,5

# 1부터 n까지의 못생긴 수를 찾기
for i in range(1,n):
  # 가능한 곱셈 결과 중에서 가장 작은 수를 선택
  ugly[i]=min(next2,next3,next5)
  # 인덱스에 따라서 곱셈 결과를 증가
  if ugly[i]==next2:
    i2+=1
    next2=ugly[i2]*2
  if ugly[i]==next3:
    i3+=1
    next3=ugly[i3]*3
  if ugly[i]==next5:
    i5+=1
    next5=ugly[i5]*5

# n번째 못생긴 수를 출력
print(ugly[n-1])