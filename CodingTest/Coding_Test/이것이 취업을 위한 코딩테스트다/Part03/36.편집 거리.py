# 3회차 풀이 - 풀이방식에 접근하지 못함
# 문자가 같은 경우와 다른 경우의 케이스를 나누지 못했다. 왜 생각하지 못했는가? 문자열이 다른 경우에, 삽입, 교체, 제거 중 가장 작은 수보다 하나 더 더해져서 +1이 되는 것까지는 생각했으나, 모든 경우에 그렇고 각 추가되는 문자열로 구분할 생각은 하지 못했다. 각 상황을 보지 못했다. 문자열이 바뀌는 상황에서 문자열이 같을 경우에는 하나를 빼고 생각했었는데 이를 캐치는 하였으나 별도로 생각에 고려하지 않았다. 왜 그랬는가? 특정 규칙이 있을 경우, 따로 고려해두는 경향이 있어야하는데, 나 같은 경우 답을 구하는 방법에만 집중하는 경향이 있다. 그래서 그것을 무시하는 경우가 많다. 다음에는 상황을 보고 그 문제조건을 시행하는 방법 중에 특이사항이 있다면 기록해 두고 그 특이사항을 적용시키려고(특히 조건문이겠죠) 노력해야 한다.

# 풀이시간 초과 시간제한 2초 메모리제한 128MB
# 2회차 풀이 - 풀이시간 초과, 풀이방식에 접근하지 못함
# 2차원 배열로 각 글자를 두고 전에 만들었던 방식에서 연산의 횟수를 늘려가는 방법인 것은 인지하고 있었으나 너무 기억에만 의존하여 풀게 되어서 답에 도달하지 못했다. 단지 그냥 2차원배열로 푸는 문제구나! 라는 것만 거의 기억에 남아있어서 원리는 없이 단지 풀이 2차원배열로 표현하는 거에만 신경썼다.
# 쉽게 말해서, dp의 목적은 최적의 해를 저장해서 다음 해를 구할 때, 전의 해를 통해 쉽게 구하는 것인데, 이게 표의 규칙성만 따지려고 하다보니까, 연산의 횟수인 것은 잊고 단순히 왜 이게 횟수의 변화를 나타내지 않지? 이러게 되버린 것이다. 즉, 현상황에서의 최적의 해를 나타내고 방향성으로 아! 이게 추가,제거,교체를 나타내는 구나, 그러면 각 문자가 추가되었을 때, 즉, 대각선으로 갔을 경우, 문자가 각 사이드에 추가되는 상황에서 그전의 상황을 이용한 최적의 해 통해 어떻게 구하지 이게되어야된다. 이 때, 규칙성을 찾기 위해서는 그 상황또한 봐야하는데 나는 그 상황을 보지를 않았다. 단순히 숫자만 본것이다. 숫자는 최적의 해만을 나타내기 때문에 상황을 나타내기에는 어렵기 때문이다. 즉, 나의 습관 중 하나, dp만으로 무언가 하려고 한다 이것보다는 dp도 보지만 상황을 dp가 어떻게 표현하는지를 보아야 한다.

a=input()
b=input()

a_len=len(a)
b_len=len(b)

dp=[[0]*(b_len) for _ in range(a_len)]

for i in range(a_len):
  for j in range(b_len):
    if i==0:
      dp[i][j]=j
    elif j==0:
      dp[i][j]=i

for i in range(1,a_len):
  for j in range(1,b_len):
    dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1

print(dp[a_len-1][b_len-1])


# 풀이시간 초과 시간제한 2초 메모리제한 128MB
# 1회차 오답 - 풀이방식에 접근하지 못함
# 풀이방식을 봐도 내가 다시 이러한 문제를 처음 접근했다면 풀이법을 생각해낼 수 있었을 거라는 생각은 들지 않는다.
# LIS처럼 특정 변형 방식을 두고 각 문제열의 변환 횟수를 누적해서 푼다고는 생각도 못했다.
# 왜 이 방식을 생각하지 못했는가? 단순히 계속 순서를 맞추어서 푸는게 아닐까도 생각해보고 DP값을 무엇으로 두어야 문제가 풀릴까 생각을 하였다. 규칙성을 찾으려고 했던 것이다. 그런데 그런 중에 규칙성을 찾지 못하였다.
# 왜 규칙성을 찾지 못하였는가? 바꾸기 위해서는 문자열을 무조건 비교해야된다고 생각하였다. 그런데 그 비교를 어떻게 기록해야될지를 생각해내지 못했다. 만약 이것을 생각했더라면 조금 더 풀이에 근접하지 않았을까 싶다. 단순 1차원 적인 기록만을 생각하고 있었다.
# 왜 1차원적인 기록만을 생각했는가? 따로 2차원적으로 보이는 요소도 없었을 뿐더러 문자끼리의 비교를 기록한다는 생각이 없었다. 꽉막힌 풀이 방식만을 고집했다. 왜? 풀이방식을 계속해서 한정적으로 생각하려고 하였다. 앞에서의 못푼 문제들이 넘쳐나다보니 그런 유형이 아닐까라는 생각이 내 생각을 틀어막고 있었다. 처음부터 다시 보는 시야가 필요했다.
# 앞에서의 풀이방식에 얽매이지 말고 개념에만 집중하려고 하는 모습이 필요할 것 같다.
# DP는 구해야겠는데 기록할게 없는거임? 그래서 계속 1차원적으로 생각해서 한쪽을 한쪽에 비교대조해서만 생각하다보니 답이 안나옴
# 2차원 적으로 DP를 기록하는 경우도 있구나를 생각해두어야 된다.

# 2회차 풀이



# 1회차 풀이 - 풀이방식에 접근하지 못함

# 답안 예시
# 최소 편집 거리(Edit Distance) 계산을 위한 다이나믹 프로그래밍
def edit_dist(sr1, str2):
  n=len(str1)
  m=len(str2)

  # 다이나믹 프로그래밍을 위한 2차원 DP 테이블 초기화
  dp=[[0]*(m+1) for _ in range(n+1)]

  # DP 테이블 초기 설정
  for i in range(1,n+1):
    dp[i][0]=i
  for j in range(1,m+1):
    dp[0][j]=j

  # 최소 편집 거리 계산
  for i in range(1,n+1):
    for j in range(1,m+1):
      # 문자가 같다면, 왼쪽 위에 해당하는 수를 그대로 대입
      if str1[i-1]==str2[j-1]:
        dp[i][j]=dp[i-1][j-1]
      # 문자가 다르다면, 3가지 경우 중에서 최솟값 찾기
      else: # 삽입(왼쪽), 삭제(위쪽), 교체(왼쪽 위) 중에서 최소 비용을 찾아 대입
        dp[i][j]=1+min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])

  return dp[n][m]

# 두 문자열을 입력받기
str1=input()
str2=input()

# 최소 편집 거리 출력
print(edit_dist(str1, str2))