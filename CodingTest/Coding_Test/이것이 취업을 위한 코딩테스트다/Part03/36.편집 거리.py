# 풀이시간 초과 시간제한 2초 메모리제한 128MB
# 1회차 오답 - 풀이방식에 접근하지 못함
# 풀이방식을 봐도 내가 다시 이러한 문제를 처음 접근했다면 풀이법을 생각해낼 수 있었을 거라는 생각은 들지 않는다.
# LIS처럼 특정 변형 방식을 두고 각 문제열의 변환 횟수를 누적해서 푼다고는 생각도 못했다.
# 왜 이 방식을 생각하지 못했는가? 단순히 계속 순서를 맞추어서 푸는게 아닐까도 생각해보고 DP값을 무엇으로 두어야 문제가 풀릴까 생각을 하였다. 규칙성을 찾으려고 했던 것이다. 그런데 그런 중에 규칙성을 찾지 못하였다.
# 왜 규칙성을 찾지 못하였는가? 바꾸기 위해서는 문자열을 무조건 비교해야된다고 생각하였다. 그런데 그 비교를 어떻게 기록해야될지를 생각해내지 못했다. 만약 이것을 생각했더라면 조금 더 풀이에 근접하지 않았을까 싶다. 단순 1차원 적인 기록만을 생각하고 있었다.
# 왜 1차원적인 기록만을 생각했는가? 따로 2차원적으로 보이는 요소도 없었을 뿐더러 문자끼리의 비교를 기록한다는 생각이 없었다. 꽉막힌 풀이 방식만을 고집했다. 왜? 풀이방식을 계속해서 한정적으로 생각하려고 하였다. 앞에서의 못푼 문제들이 넘쳐나다보니 그런 유형이 아닐까라는 생각이 내 생각을 틀어막고 있었다. 처음부터 다시 보는 시야가 필요했다.
# 앞에서의 풀이방식에 얽매이지 말고 개념에만 집중하려고 하는 모습이 필요할 것 같다.
# DP는 구해야겠는데 기록할게 없는거임? 그래서 계속 1차원적으로 생각해서 한쪽을 한쪽에 비교대조해서만 생각하다보니 답이 안나옴
# 2차원 적으로 DP를 기록하는 경우도 있구나를 생각해두어야 된다.

# 2회차 풀이



# 1회차 풀이 - 풀이방식에 접근하지 못함

# 답안 예시
# 최소 편집 거리(Edit Distance) 계산을 위한 다이나믹 프로그래밍
def edit_dist(sr1, str2):
  n=len(str1)
  m=len(str2)

  # 다이나믹 프로그래밍을 위한 2차원 DP 테이블 초기화
  dp=[[0]*(m+1) for _ in range(n+1)]

  # DP 테이블 초기 설정
  for i in range(1,n+1):
    dp[i][0]=i
  for j in range(1,m+1):
    dp[0][j]=j

  # 최소 편집 거리 계산
  for i in range(1,n+1):
    for j in range(1,m+1):
      # 문자가 같다면, 왼쪽 위에 해당하는 수를 그대로 대입
      if str1[i-1]==str2[j-1]:
        dp[i][j]=dp[i-1][j-1]
      # 문자가 다르다면, 3가지 경우 중에서 최솟값 찾기
      else: # 삽입(왼쪽), 삭제(위쪽), 교체(왼쪽 위) 중에서 최소 비용을 찾아 대입
        dp[i][j]=1+min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])

  return dp[n][m]

# 두 문자열을 입력받기
str1=input()
str2=input()

# 최소 편집 거리 출력
print(edit_dist(str1, str2))