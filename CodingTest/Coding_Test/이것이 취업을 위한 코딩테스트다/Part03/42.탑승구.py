# 풀이시간 초과 시간제한 1초 메모리제한 128MB
# 1회차 오답 - 풀이방식 접근하지 못함
# 간선과 정점의 개수가 100,000이라고 했을 때, 그래프 이론에서 나온 모든 알고리즘이 가능하다고 생각했다. 그렇지만 아무리 생각해봐도 위상 정렬은 될 수 없으며, 크루스칼 알고리즘도 아니라고 생각했다. 그렇기에 무조건 서로소 집합을 이용한 풀이여야 한다는 결론을 내렸다.
# 서로소 집합을 이용하는 경우는 그룹을 나누고 그 그룹이 연결되어 있는지, 아닌지를 보아야 된다고 생각했기 때문에, 계속 해서 간선에 집착하게 되었다. 그러나 그룹을 나누는 식의 그래프 형태는 나오지 않았고 답으로 이어지지도 않았다.
# 문제가 간선에 대해 주지 않는다면, 간선을 연결하는 경우를 내가 생각해야 된다고 생각할만 했지만, 정점끼리 연결하는데 너무 집착하는 나머지, 간선에 대한 정보가 없고, 원하는 그래프 형태가 나오지 않아도 다른 쪽으로 생각하지 못했다.
# 즉, 이 문제를 풀지못한 가장 큰 이유는 서로소 집합 문제가 그룹을 나누고 그 그룹으로 문제를 푸는 것이라는 좁은 생각을 가지고 있었기 때문이다.
# 그래프 형태가 문제를 풀기 적합하지 않고, 이러한 문제처럼 간선에 대한 정보가 없다면, 이미 모든 정보를 주고 다른 방식으로 간선을 연결하지 않나를 살펴봐야 한다. 서로소 집합 문제는 union-find 에 의존한다는 것을 말이다.

# 2회차 풀이




# 1회차 풀이

# 답안 예시
# 특정 원소가 속한 집합을 찾기
def find_parent(parent,x):
  # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
  if parent[x]!=x:
    parent[x]=find_parent(parent,parent[x])
  return parent[x]

# 두 원소가 속한 집합을 합치기
def union_parent(parent,a,b):
  a=find_parent(parent,a)
  b=find_parent(parent,b)
  if a<b:
    parent[b]=a
  else:
    parent[a]=b

# 탑승구의 개수 입력받기
g=int(input())
# 비행기의 개수 입력받기
p=int(input())

# 부모 테이블 초기화
parent=[0]*(g+1)

# 부모 테이블상에서, 부모를 자기 자신으로 초기화
for i in range(1,g+1):
  parent[i]=i

result=0
for _ in range(p):
  data=find_parent(parent,int(input())) # 현재 비행기의 탑승구의 루트 확인
  if data==0: # 현재 루트가 0이라면, 종료
    break
  union_parent(parent,data,data-1) # 그렇지 않다면 바로 왼쪽의 집합과 합치기
  result+=1

print(result)