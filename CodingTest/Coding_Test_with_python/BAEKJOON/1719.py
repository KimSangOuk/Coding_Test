# 풀이시간 초과 시간제한 2초 메모리제한 128MB
# 1회차 오답 - 풀이방법에 접근하지 못함, 풀이시간 초과
# 각 최단거리의 경로에서 맨 처음 방문하는 지점을 나타내기 위해서는 모든 경로를 나타내야한다고 생각해서, 경로를 각 찾으려고 하였으나 탐색을 또 따로 쓰지 않는 이상 푸는 방법이 생각나지 않았고 시간복잡도 상으로 불가능하다고 생각이 됨. 그래서 플로이드 워셜 알고리즘으로 경로를 먼저 구한 후 이에 최단이 되는 경우에 맞추어 시작점에서 출발했을 때, 바로 들리는 값만을 출력했으나 이는 다른 값을 구할 수 없는 한계가 있었음.
# 각 최단 경로를 구하는 과정에서 k를 중간에 들리는 경우, k값이 가장 노드에 가깝게 갱신이 되는데 특정 노드를 통해 지나쳐 갈 때, 가장 앞에 노드만으로 갱신이 되기 때문에 다른 경로와 해도 갱신이 되는 것이었다. 왜 이 아이디어를 생각하지 못했는가? 경로를 통해 맨 앞에 있는 노드를 구해야한다고 생각했고 또한 k를 지나치면서 갱신될 때, 다른 경로의 합으로 이루어지기 때문에 갱신되는 측면에서 가장 빠른게 갱신된다고는 생각하지 못했음. 답을 내는 2차원 배열에서 즉, 경로에서 가장 빠른 노드를 답으로 하는 2차원 배열을 갱신할 때의 상황에서 다른 갱신된 값의 영향을 받아 제일 빠르게 생신된다고 생각하지 못함. 왜 생각하지 못했는가? 거리의 경우 가장 먼곳에 있더라도 땡겨지는 상황만을 생각했는데, 역으로 가장 가까운 노드에서 다른 먼 상황을 갱신한다고 생각하지 못했음. 왜? 경로가 달라지면 노드의 적용이 무효해진다고 생각했기 때문이다. 왜? 계속해서 k값 즉 중간에 나타내는 값으로만 갱신을 하려고 했다. 왜? 특정 노드를 지나치는 문제라고 생각하니, k가 지나칠 때라는 생각이 들었기 때문이다. 즉, k라는 노드를 경유하는 생각에 한정지어 생각했기 때문에 특정경유를 다른 배열의 값이 아닌 k로 갱신하려고 하였고 틀린것이다. 왜 k라는 노드에 한 정지었는가? 답을 구하기 보다는 경유해야한다는 생각에 갇혀있어서 목적지에만 집착을 한것인데, 즉, 2차원 배열을 단순 연결간의 연결이 아닌 출발지와 목적지와의 형태로 바라보았다. 그러다 보니, 목적지의 값으로 k를 갱신한 것이고 답이 나올 수 없었다. 통합적인 값을 보지 못하고 1차원적인 틀에서 바라보는 습관 때문에, 경로들이 목적지들의 합이라고 생각했고, 모든 경로를 이어서 특정 최단 경로를 이뤄야한다고 그렇기에 생각했기에, 특정 경우가 갱신될꺼라고는 생각을 못했다.
# 즉, 다음부터 이렇게 갱신되는 경우가 있을 경우, 그 안에 내포되어있는 갱신되는 의미를 알고, 다른 값들에 의해 현재의 값이 순차적으로 갱신이 될 수 있는지를 바라보아야 한다.


# 답안지
import sys

input = sys.stdin.readline
N, M = map(int, input().split())
INF = int(1e9)

graph = [[INF] * (N + 1) for _ in range(N + 1)]
ans = [[0] * (N + 1) for _ in range(N + 1)]

for a in range(N + 1):
    for b in range(N + 1):
        if a == b:
            graph[a][b] = 0
            ans[a][b] = INF

for _ in range(M):
    v1, v2, route = map(int, input().split())
    # 양방향 그래프이므로
    graph[v1][v2] = route
    graph[v2][v1] = route
    # v1 출발 -> v2 도착이면 v1 기준으로 v2가 도착지점이 되어야함.
    ans[v1][v2] = v2
    # 위와 반대
    ans[v2][v1] = v1

# 플로이드 워셜 알고리즘 (점화식 이용 --> DP)
for k in range(1, N + 1):
    for a in range(1, N + 1):
        for b in range(1, N + 1):
            # 기존의 a -> b로 가는 저장된 비용보다
            # a -> k -> b로 가는 경로가 더 최단 거리이면
            if graph[a][b] > graph[a][k] + graph[k][b]:
                # 비용을 최단 거리로 갱신
                graph[a][b] = graph[a][k] + graph[k][b]
                # 먼저 들러야하는 지점인 (a, k)의 집하장 값으로 갱신
                ans[a][b] = ans[a][k]

for i in range(1, N + 1):
    for j in range(1, N + 1):
        if ans[i][j] == INF:
            print('-', end=' ')
        else:
            print(ans[i][j], end=' ')
    print()