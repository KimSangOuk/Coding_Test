# 풀이시간 25분 시간제한 0.5초 메모리제한 128MB
# 1회차 정답
# 각 다리가 연결되는 값을 우리는 구하고 있으므로 그 값을 dp의 기준으로 보고 2차원 배열로 나타냈다. 그 2차원 배열을 보았을 때, 각 수는 각 조합의 수 이므로 이 수를 표로 나타내는 과정 중의 규칙으로 한다리씩 없을 때의 수에 m/n을 곱해주면 된다고 생각했다.
# 시간복잡도는 2차원 배열이 아무리 커도 900이므로 가능하다.
# 처음에 이렇게 규칙을 찾아도 dp일까 싶었지만 질문 중 하나에서 조합을 빨리 구하는 방법 중 하나도 다이나믹 프로그래밍이 될 수 있다. 이 질문의 답을 보고 납득했다.

for tc in range(int(input())):
  n,m=map(int,input().split())

  arr=[[0]*(m+1) for _ in range(n+1)]

  for i in range(1,n+1):
    for j in range(i,m+1):
      if i==1:
        arr[i][j]=j
      else:
        arr[i][j]=arr[i-1][j-1]*j//i

  print(arr[n][m])