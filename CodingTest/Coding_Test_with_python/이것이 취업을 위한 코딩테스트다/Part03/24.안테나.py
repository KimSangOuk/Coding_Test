# 풀이시간 10분/20분 시간제한 1초 메모리제한 128MB
# 2회차 정답
# 특정 지점에서 다른 지점까지의 거리의 합이 최소가 되는 지점을 찾는 것이기 때문에, 여러가지 경우를 따져본 결과, 인덱스가 중앙 값이 된 지점이 다른 지점으로 부터의 거리의 합이 최소가 되는 지점이 된다. 그 이유는 중앙에서 벗어날 수록 멀어진 한 쪽 사이드 값과의 차가 더 커지기 때문이다. 데이터의 수는 최대 200,000이므로 O(NlogN)으로 정렬 가능하다.

n=int(input())
array=list(map(int,input().split()))

array.sort()
if n%2==0:
  print(array[n//2-1])
else:
  print(array[n//2])

# 풀이시간 over/20분 시간제한 1초 메모리제한 128MB
# 1회차 오답 - 풀이방식 접근 못함
# 먼저 데이터의 수가 200,000이기 때문에 정렬 방식은 O(NlogN)의 퀵 정렬이나 계수 정렬을 사용할 수 밖에 없다. 그렇기에 정렬을 sort()를 사용해서 진행하였다. 거리의 합이 최소가 되는 점을 찾는 문제였는데, 최소가 되는 점을 찾는 방식을 내가 생각해내지 못했다.
# 그래서 공식을 찾으려고 머리를 엄청나게 굴려봤지만 딱히 그런건 없었다. 그냥 나열 된 좌표 중 중앙 값을 출력하는 되는 문제였다. 수학적으로 이해가 안된다.
# 챗 GPT와 수다를 떨어본 결과 중앙값일 때, 최소가 된다면, 그 중앙값에서 멀어지면서 중앙값과의 추가 거리분이 발생하면서 총량이 늘어나게 된단다. 후....

# 1회차 풀이
n=int(input())
arr=list(map(int,input().split()))

arr.sort()
value=sum(arr)/len(arr)

answer=0
t=200000
for k in arr:
  if abs(k-value)<t:
    answer=k
    t=abs(k-value)
    

print(answer)